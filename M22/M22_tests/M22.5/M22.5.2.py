"""
Задание 22.5.2
Возьмите граф из предыдущего задания (с картой метро) и постройте из него взвешенный граф.
В качестве весов используйте время, необходимое для того, чтобы доехать (или перейти) с одной станции на другую.
Для этого можно воспользоваться сервисом Яндекс.Метро.
"""
G = {"Адмиралтейская" :
         {"Садовая" : 4},
     "Садовая" :
         {"Сенная площадь" : 3,
          "Спасская" : 3,
          "Адмиралтейская" : 4,
          "Звенигородская" : 5},
     "Сенная площадь" :
         {"Садовая" : 3,
          "Спасская" : 3},
     "Спасская" :
         {"Садовая" : 3,
          "Сенная площадь" : 3,
          "Достоевская" : 4},
     "Звенигородская" :
         {"Пушкинская" : 3,
          "Садовая" : 5},
     "Пушкинская" :
         {"Звенигородская" : 3,
          "Владимирская" : 4},
     "Владимирская" :
         {"Достоевская" : 3,
          "Пушкинская" : 4},
     "Достоевская" :
         {"Владимирская" : 3,
          "Спасская" : 4}}
"""
Для начала нам потребуется дополнительная структура данных для хранения расстояний. 
Если вершины пронумерованы числами, то можно использовать массив, 
но т. к. мы имеем проименованные узлы, то удобнее пользоваться словарём.
"""
D = {k : 100 for k in G.keys()}

"""
Проинициализируем словарь расстояний числами, которые заведомо больше максимального расстояния в графе. 
Значения 100 в данной задаче нам будет более чем достаточно. 
Одну из вершин мы должны выбрать как стартовую. Поэтому стартовая вершина будет предком для всех остальных. 
Расстояние для неё (от неё же самой) будет равно нулю. Пусть это будет «Адмиралтейская».
"""
D["Адмиралтейская"] = 0

"""
Также нам потребуется хранить словарь с булевыми значениями, в котором True — если вершина просмотрена, иначе — False.
"""
U = {k : False for k in G.keys()}
"""
Далее мы должны пройти циклом из n итераций, выбирая вершину с наименьшим D среди непросмотренных. 
Очевидно, что на первой итерации будет выбрана стартовая вершина. 
Из неё мы должны проверить все вершины, в которые можем перейти, и в D записать наименьшее расстояние до них. 
Пока что мы можем идти только из стартовой вершины, поэтому запишутся именно эти расстояния. 
Стартовая вершина станет помеченной как уже просмотренная. 
После чего начнется поиск вершины с минимальным D из уже просмотренных (куда можно добраться из стартовой). 
От неё также будут строиться возможные ребра и проверяться минимум расстояний. И так далее, пока процесс не завершится. 
Утверждается, что достаточно числа итераций равного количеству вершин. При достижении этого алгоритм завершится корректно.
"""
D = {k : 100 for k in G.keys()} # расстояния
start_k = 'Адмиралтейская' # стартовая вершина
D[start_k] = 0 # расстояние от неё до самой себя равно нулю
U = {k : False for k in G.keys()} # флаги просмотра вершин

for _ in range(len(D)):
    # выбираем среди непросмотренных наименьшее по расстоянию
    min_k = min([k for k in U.keys() if not U[k]], key = lambda x: D[x])

    for v in G[min_k].keys(): # проходимся по всем смежным вершинам
        D[v] = min(D[v], D[min_k] + G[min_k][v]) # минимум
    U[min_k] = True # просмотренную вершину помечаем
"""
Результат работы программы можно увидеть в словаре D.
"""
print(D)

# {'Адмиралтейская': 0,
#  'Садовая': 4,
#  'Сенная площадь': 7,
#  'Спасская': 7,
#  'Звенигородская': 9,
#  'Пушкинская': 12,
#  'Владимирская': 14,
#  'Достоевская': 11}

"""
Алгоритм Дейкстры можно модифицировать таким образом, что можно определить не только величину пути, 
но ещё и сами вершины минимального пути.

Для этого определим ещё один словарь P, в котором будем для каждой вершины хранить вершину-предок с минимальным расстоянием.
"""
P = {k : None for k in G.keys()}
print(P)
